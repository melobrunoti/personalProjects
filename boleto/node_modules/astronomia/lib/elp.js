"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.position = position;
exports["default"] = exports.Moon = void 0;

var _base = _interopRequireDefault(require("./base"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

var SEC2RAD = 1 / 3600 * Math.PI / 180;

function sum(T, series) {
  var coeffs = [];
  Object.keys(series).forEach(function (x) {
    coeffs[x] = 0.0;
    var y = series[x].length - 1;

    for (y; y >= 0; y--) {
      // A, t0, t1, t2, t3, t4
      var row = series[x][y];

      var φ = _base["default"].horner(T, row.slice(1));

      coeffs[x] += row[0] * Math.sin(φ);
    }
  });
  return _base["default"].horner(T, coeffs);
}
/**
 *
 */


var Moon = /*#__PURE__*/function () {
  /**
   * ELP representation of a Moon
   * @constructs Moon
   * @param {object} data - elp data series
   * @example
   * ```js
   * // for use in browser
   * import {data} from 'astronomia'
   * const moon = new elp.Moon(data.elpMppDe)
   * ```
   */
  function Moon(data) {
    _classCallCheck(this, Moon);

    if (_typeof(data) !== 'object') throw new TypeError('need Elp data');
    this.series = data;
  }

  _createClass(Moon, [{
    key: "_calcLBR",
    value: function _calcLBR(T) {
      var L = _base["default"].horner(T, this.series.W1) + sum(T, this.series.L) * SEC2RAD;
      var B = sum(T, this.series.B) * SEC2RAD;
      var R = sum(T, this.series.R);
      return {
        L: _base["default"].pmod(L, 2 * Math.PI),
        B: B,
        R: R
      };
    }
    /**
     * Position returns rectangular coordinates referred to the inertial mean ecliptic and equinox of J2000.
     * @param {Number} jde - Julian ephemeris day
     * @return {object} rectangular coordinates
     *   {Number} x
     *   {Number} y
     *   {Number} z
     */

  }, {
    key: "positionXYZ",
    value: function positionXYZ(jde) {
      var T = _base["default"].J2000Century(jde);

      var _this$_calcLBR = this._calcLBR(T),
          L = _this$_calcLBR.L,
          B = _this$_calcLBR.B,
          R = _this$_calcLBR.R;

      var x = R * Math.cos(L) * Math.cos(B);
      var y = R * Math.sin(L) * Math.cos(B);
      var z = R * Math.sin(B);

      var P = _base["default"].horner(T, 0, 0.10180391e-4, 0.47020439e-6, -0.5417367e-9, -0.2507948e-11, 0.463486e-14);

      var Q = _base["default"].horner(T, 0, -0.113469002e-3, 0.12372674e-6, 0.12654170e-8, -0.1371808e-11, -0.320334e-14);

      var sq = Math.sqrt(1 - P * P - Q * Q);
      var p11 = 1 - 2 * P * P;
      var p12 = 2 * P * Q;
      var p13 = 2 * P * sq;
      var p21 = 2 * P * Q;
      var p22 = 1 - 2 * Q * Q;
      var p23 = -2 * Q * sq;
      var p31 = -2 * P * sq;
      var p32 = 2 * Q * sq;
      var p33 = 1 - 2 * P * P - 2 * Q * Q;
      var result = {
        x: p11 * x + p12 * y + p13 * z,
        y: p21 * x + p22 * y + p23 * z,
        z: p31 * x + p32 * y + p33 * z
      };
      return result;
    }
    /**
     * Position returns ecliptic position of moon at equinox and ecliptic of date.
     *
     * @param {Number} jde - the date for which positions are desired.
     * @returns {base.Coord} Results are positions consistent with those elp data,
     * that is, at equinox and ecliptic of date.
     *  {Number} lon - geocentric longitude in radians.
     *  {Number} lat - geocentric latitude in radians.
     *  {Number} range - geocentric range in KM.
     */

  }, {
    key: "position",
    value: function position(jde) {
      var T = _base["default"].J2000Century(jde);

      var _this$_calcLBR2 = this._calcLBR(T),
          L = _this$_calcLBR2.L,
          B = _this$_calcLBR2.B,
          R = _this$_calcLBR2.R; // precession


      var pA = _base["default"].horner(T, 0, 5029.0966, 1.1120, 0.000077, -0.00002353) * SEC2RAD;
      return new _base["default"].Coord(_base["default"].pmod(L + pA, 2 * Math.PI), B, R);
    }
  }]);

  return Moon;
}();
/**
 * Position returns the true geometric position of the moon as ecliptic coordinates.
 *
 * Result computed by Elp theory.  Result is at equator and equinox
 * of date in the FK5 frame.  It does not include nutation or aberration.
 *
 * @param {Object} elpData
 * @param {Number} jde - Julian ephemeris day
 * @returns {Object}
 *   {Number} lon - ecliptic longitude in radians
 *   {Number} lat - ecliptic latitude in radians
 *   {Number} range - range in KM
 */


exports.Moon = Moon;

function position(elpData, jde) {
  var moon = new Moon(elpData);
  return moon.position(jde);
}

var _default = {
  Moon: Moon,
  position: position
};
exports["default"] = _default;